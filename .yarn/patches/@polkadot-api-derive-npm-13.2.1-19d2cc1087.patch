diff --git a/cjs/staking/query.js b/cjs/staking/query.js
index 24826c714d1c6609d65ec379c385e9331e9e30cf..5da18f5c8beb005023beb078051ec22fd5f40210 100644
--- a/cjs/staking/query.js
+++ b/cjs/staking/query.js
@@ -58,7 +58,8 @@ function filterRewards(stashIds, eras, claimedRewards, stakersOverview) {
         });
     });
 }
-function parseDetails(api, stashId, controllerIdOpt, nominatorsOpt, rewardDestinationOpts, validatorPrefs, exposure, stakingLedgerOpt, exposureMeta, claimedRewards, exposureEraStakers) {
+function parseDetails(api, stashId, controllerIdOpt, nominatorsOpt, rewardDestinationOpts, validatorPrefs, exposure, stakingLedgerOpt, exposureMeta, claimedRewards, exposureEraStakers, exposurePagedAll) {
+
     return {
         accountId: stashId,
         claimedRewardsEras: filterClaimedRewards(api, claimedRewards),
@@ -72,7 +73,8 @@ function parseDetails(api, stashId, controllerIdOpt, nominatorsOpt, rewardDestin
         rewardDestination: rewardDestinationCompat(rewardDestinationOpts),
         stakingLedger: stakingLedgerOpt.unwrapOrDefault(),
         stashId,
-        validatorPrefs
+        validatorPrefs,
+        allOtherNominators: exposurePagedAll.flatMap(([_, exposurePage]) => exposurePage.others)
     };
 }
 function getLedgers(api, optIds, { withLedger = false }) {
@@ -133,11 +135,14 @@ function getStashInfo(api, stashIds, activeEra, { withClaimedRewardsEras, withCo
             : (0, rxjs_1.of)(stashIds.map(() => emptyClaimedRewards)),
         withExposureErasStakersLegacy && api.query.staking.erasStakers
             ? (0, rxjs_1.combineLatest)(stashIds.map((s) => api.query.staking.erasStakers(activeEra, s)))
-            : (0, rxjs_1.of)(stashIds.map(() => emptyExpoEraStakers))
+            : (0, rxjs_1.of)(stashIds.map(() => emptyExpoEraStakers)),
+        withExposure && api.query.staking.erasStakersPaged
+            ? (0, rxjs_1.combineLatest)(stashIds.map((s) => api.query.staking.erasStakersPaged.entries(activeEra, s)))
+            : (0, rxjs_1.of)(stashIds.map(() => [])),
     ]);
 }
 function getBatch(api, activeEra, stashIds, flags, page) {
-    return getStashInfo(api, stashIds, activeEra, flags, page).pipe((0, rxjs_1.switchMap)(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure, exposureMeta, claimedRewardsEras, exposureEraStakers]) => getLedgers(api, controllerIdOpt, flags).pipe((0, rxjs_1.map)((stakingLedgerOpts) => stashIds.map((stashId, index) => parseDetails(api, stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index], exposureMeta[index], claimedRewardsEras[index], exposureEraStakers[index]))))));
+    return getStashInfo(api, stashIds, activeEra, flags, page).pipe((0, rxjs_1.switchMap)(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure, exposureMeta, claimedRewardsEras, exposureEraStakers, exposurePagedAll]) => getLedgers(api, controllerIdOpt, flags).pipe((0, rxjs_1.map)((stakingLedgerOpts) => stashIds.map((stashId, index) => parseDetails(api, stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index], exposureMeta[index], claimedRewardsEras[index], exposureEraStakers[index], exposurePagedAll[index]))))));
 }
 /**
  * @description From a stash, retrieve the controllerId and all relevant details
diff --git a/cjs/staking/validators.js b/cjs/staking/validators.js
index 5d74f9b00630b7cbfe1fbab5cf584b18465be262..d1cb3892e363ef18209e048785cecfc6e7311b23 100644
--- a/cjs/staking/validators.js
+++ b/cjs/staking/validators.js
@@ -7,11 +7,12 @@ const index_js_1 = require("../util/index.js");
 function nextElected(instanceId, api) {
     return (0, index_js_1.memo)(instanceId, () => 
     // Compatibility for future generation changes in staking.
-    api.query.staking.erasStakersPaged
+    api.query.staking.erasStakersOverview
         ? api.derive.session.indexes().pipe(
         // only populate for next era in the last session, so track both here - entries are not
         // subscriptions, so we need a trigger - currentIndex acts as that trigger to refresh
-        (0, rxjs_1.switchMap)(({ currentEra }) => api.query.staking.erasStakersPaged.keys(currentEra)), 
+        (0, rxjs_1.switchMap)(({ currentEra }) => api.query.staking.erasStakersOverview.keys(currentEra).pipe(map((keys) => [keys, currentEra]))),
+        (0, rxjs_1.switchMap)(([keys, currentEra]) => keys.length === 0 && api.query.staking.erasStakers ? api.query.staking.erasStakers.keys(currentEra) : of(keys)),
         // Dedupe any duplicates
         (0, rxjs_1.map)((keys) => [...new Set(keys.map(({ args: [, accountId] }) => accountId.toString()))].map((a) => api.registry.createType('AccountId', a))))
         : api.query.staking.erasStakers
diff --git a/staking/query.js b/staking/query.js
index f9448e7b554df170c96971eccbe0c3c94f0fd695..0a3c5465701ca9438d9c4909161adb8229978eb4 100644
--- a/staking/query.js
+++ b/staking/query.js
@@ -54,7 +54,7 @@ function filterRewards(stashIds, eras, claimedRewards, stakersOverview) {
         });
     });
 }
-function parseDetails(api, stashId, controllerIdOpt, nominatorsOpt, rewardDestinationOpts, validatorPrefs, exposure, stakingLedgerOpt, exposureMeta, claimedRewards, exposureEraStakers) {
+function parseDetails(api, stashId, controllerIdOpt, nominatorsOpt, rewardDestinationOpts, validatorPrefs, exposure, stakingLedgerOpt, exposureMeta, claimedRewards, exposureEraStakers, exposurePagedAll) {
     return {
         accountId: stashId,
         claimedRewardsEras: filterClaimedRewards(api, claimedRewards),
@@ -68,7 +68,8 @@ function parseDetails(api, stashId, controllerIdOpt, nominatorsOpt, rewardDestin
         rewardDestination: rewardDestinationCompat(rewardDestinationOpts),
         stakingLedger: stakingLedgerOpt.unwrapOrDefault(),
         stashId,
-        validatorPrefs
+        validatorPrefs,
+        allOtherNominators: exposurePagedAll.flatMap(([_, exposurePage]) => exposurePage.unwrapOrDefault().others)
     };
 }
 function getLedgers(api, optIds, { withLedger = false }) {
@@ -129,11 +130,14 @@ function getStashInfo(api, stashIds, activeEra, { withClaimedRewardsEras, withCo
             : of(stashIds.map(() => emptyClaimedRewards)),
         withExposureErasStakersLegacy && api.query.staking.erasStakers
             ? combineLatest(stashIds.map((s) => api.query.staking.erasStakers(activeEra, s)))
-            : of(stashIds.map(() => emptyExpoEraStakers))
+            : of(stashIds.map(() => emptyExpoEraStakers)),
+        withExposure && api.query.staking.erasStakersPaged
+            ? combineLatest(stashIds.map((s) => api.query.staking.erasStakersPaged.entries(activeEra, s)))
+            : of(stashIds.map(() => [])),
     ]);
 }
 function getBatch(api, activeEra, stashIds, flags, page) {
-    return getStashInfo(api, stashIds, activeEra, flags, page).pipe(switchMap(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure, exposureMeta, claimedRewardsEras, exposureEraStakers]) => getLedgers(api, controllerIdOpt, flags).pipe(map((stakingLedgerOpts) => stashIds.map((stashId, index) => parseDetails(api, stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index], exposureMeta[index], claimedRewardsEras[index], exposureEraStakers[index]))))));
+    return getStashInfo(api, stashIds, activeEra, flags, page).pipe(switchMap(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure, exposureMeta, claimedRewardsEras, exposureEraStakers, exposurePagedAll]) => getLedgers(api, controllerIdOpt, flags).pipe(map((stakingLedgerOpts) => stashIds.map((stashId, index) => parseDetails(api, stashId, controllerIdOpt[index], nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index], stakingLedgerOpts[index], exposureMeta[index], claimedRewardsEras[index], exposureEraStakers[index], exposurePagedAll[index]))))));
 }
 /**
  * @description From a stash, retrieve the controllerId and all relevant details
diff --git a/staking/validators.js b/staking/validators.js
index bfaae2c0e0da493cc09b60fbb45ad9ceef0faf27..fa49037f2e822dd95b7208199d454d66cb8eddbf 100644
--- a/staking/validators.js
+++ b/staking/validators.js
@@ -3,11 +3,12 @@ import { memo } from '../util/index.js';
 export function nextElected(instanceId, api) {
     return memo(instanceId, () => 
     // Compatibility for future generation changes in staking.
-    api.query.staking.erasStakersPaged
+    api.query.staking.erasStakersOverview
         ? api.derive.session.indexes().pipe(
         // only populate for next era in the last session, so track both here - entries are not
         // subscriptions, so we need a trigger - currentIndex acts as that trigger to refresh
-        switchMap(({ currentEra }) => api.query.staking.erasStakersPaged.keys(currentEra)), 
+        switchMap(({ currentEra }) => api.query.staking.erasStakersOverview.keys(currentEra).pipe(map((keys) => [keys, currentEra]))),
+        switchMap(([keys, currentEra]) => keys.length === 0 && api.query.staking.erasStakers ? api.query.staking.erasStakers.keys(currentEra) : of(keys)),
         // Dedupe any duplicates
         map((keys) => [...new Set(keys.map(({ args: [, accountId] }) => accountId.toString()))].map((a) => api.registry.createType('AccountId', a))))
         : api.query.staking.erasStakers
